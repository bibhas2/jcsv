/*
 * This source file was generated by the Gradle 'init' task
 */
package org.mobiarch.jcsv;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.function.Consumer;

/**
 * <p>A zero copy CSV file parser that doesn't
 * allocate any memory or copy data to read the text in the file.
 * It uses a combination of file mapping and ByteBuffer to achieve
 * this.</p>
 * <p>Each line in a CSV file is called a record. Each record is made
 * up of a number of fields. The fields are created by taking slices
 * from the ByteBuffer of the whole document.</p>
 * 
 */
public class Parser {
    /**
     * This class represents a record (line or row) in a CSV
     * document.
     */
    public class Record {
        private int lineIndex;
        private int numFields;
        private ByteBuffer[] fields;

        /**
         * Returns the index of the line starting with 0.
         * @return The zero based line number of the record.
         */
        public int lineIndex() {
            return lineIndex;
        }

        /**
         * Returns the number of fields available in the record.
         * This will not be more than the maxFields parameter supplied
         * to Parser.parse() method.
         * @return The number of fields available in the record.
         */
        public int numFields() {
            return numFields;
        }

        private ByteBuffer[] fields() {
            return fields;
        }

        /**
         * Returns a field for the specified index.
         * 
         * @param index The index of the field.
         * @return A ByteBuffer representing the field.
         */
        public ByteBuffer field(int index) {
            if (index >= numFields) {
                throw new ArrayIndexOutOfBoundsException("Fields available: " + numFields);
            }

            return fields[index];
        }

        /**
         * Returns an integer value for a field.
         * 
         * @param index The index of the field.
         * @return Integer value of the field.
         */
        public int intField(int index) {
            return Parser.parseInt(field(index));
        }

        /**
         * Returns a double value of a field.
         * 
         * @param index The index of the field.
         * @return Double value of the field.
         */
        public double doubleField(int index) {
            return Parser.parseDouble(field(index));
        }
    }

    private enum ParseStatus {
        INVALID_STATE,
        HAS_MORE_FIELDS,
        END_RECORD,
        END_DOCUMENT
    }

    ParseStatus status = ParseStatus.INVALID_STATE;

    /**
     * <p>Memory maps a UTF-8 encoded CSV file and parses it. 
     * For each record (line) the supplied
     * consumer function is called. Each record is made up
     * of zero or more comma separated fields.</p>
     * 
     * <p>No new memory is allocated or copied for the text data.
     * Each field is a slice into the data stored in the file.</p>
     * 
     * @param filePath The CSV file to parse.
     * @param maxFields Maximum number of fields that will be returned
     * to the consumer function. If you have more fields in a line then the 
     * excess ones are ignored.
     * @param f The consumer function that is called for each record (line). It
     * receoves a Record object as input. The Record object may be reused for 
     * the subsequent records. 
     */
    public void parse(String filePath, int maxFields, Consumer<Record> f) throws FileNotFoundException, IOException {
        try (var file = new RandomAccessFile(filePath, "r")) {
            //Memory map the file
            var buff = file.getChannel()
                    .map(FileChannel.MapMode.READ_ONLY, 0, file.length());

            parse(buff, maxFields, f);
        } 
    }

    /**
     * <p>Parses a UTF-8 encoded ByteBuffer for comma
     * separate records. For each record (line) the supplied
     * consumer function is called. Each record is made up
     * of zero or more comma separated fields.</p>
     * 
     * <p>No new memory is allocated or copied for the text data.
     * Each field is a slice into the supplied data.</p>
     * 
     * @param data The ByteBuffer to parse.
     * @param maxFields Maximum number of fields that will be returned
     * to the consumer function. If you have more fields in a line then the 
     * excess ones are ignored.
     * @param f The consumer function that is called for each record (line). It
     * receoves a Record object as input.
     */
    public void parse(ByteBuffer data, int maxFields, Consumer<Record> f) {
        var record = new Record();
        var fields = new ByteBuffer[maxFields];

        record.fields = fields;

        status = ParseStatus.INVALID_STATE;
        int index = 0;

        while (true) {
            parseRecord(data, record);
            
            if (status == ParseStatus.END_DOCUMENT) {
                if (record.numFields() == 0) {
                    break;
                } else {
                    //This happens when a file doesn't end 
                    //properly with a CR LF or LF.
                }
            }

            record.lineIndex = index;

            f.accept(record);

            ++index;
        }
    }

    /**
     * Get the byte at current position without advancing the position.
     * 
     * @param data
     * @return
     */
    private byte peek(ByteBuffer data) {
        return data.get(data.position());
    }

    private byte pop(ByteBuffer data) {
        return data.get();
    }

    /**
     * Parses a single line at the current position.
     * 
     * @param data
     * @param record
     * @return
     */
    private void parseRecord(ByteBuffer data, Record record) {
        record.numFields = 0;
        status = ParseStatus.INVALID_STATE;

        while (true) {
            ByteBuffer field = nextField(data);

            if (field != null && record.numFields() < record.fields().length) {
                record.fields()[record.numFields()] = field;

                ++record.numFields;
            }

            if (status == ParseStatus.END_RECORD ||
                status == ParseStatus.END_DOCUMENT) {
                return;
            }
        }
    }

    private int markStop(ByteBuffer data) {
        return data.position() > 0 ? (data.position() - 1) : 0;
    }

    private ByteBuffer nextField(ByteBuffer data) {
        boolean insideDquote = false;
        boolean escapedField = false;
        int fieldStart = data.position();
        int fieldEnd = -1;//markStop(data);

        while (true) {
            if (!data.hasRemaining()) {
                status = ParseStatus.END_DOCUMENT;

                return null;
            }

            byte ch = pop(data);

            if (ch == '"') {
                if (!insideDquote) {
                    insideDquote = true;
                    escapedField = true;

                    fieldStart = data.position();
                } else {
                    if (peek(data) == '"') {
                        // Still inside dquote
                        pop(data);
                    } else {
                        // We are out of dquote
                        insideDquote = false;

                        fieldEnd = markStop(data);
                    }
                }

                continue;
            }

            if (insideDquote) {
                continue;
            }

            if (ch == ',') {
                if (!escapedField) {
                    fieldEnd = markStop(data);
                }
                
                status = ParseStatus.HAS_MORE_FIELDS;

                return segment(data, fieldStart, fieldEnd);
            }
            
            if (ch == '\r') {
                if (!escapedField) {
                    fieldEnd = markStop(data);
                }
                
                pop(data); //Read the LF \n

                status = ParseStatus.END_RECORD;
                
                return segment(data, fieldStart, fieldEnd);
            }
            
            /*
             * Non-standard end of line with just a LF \n
             */
            if (ch == '\n') {
                if (!escapedField) {
                    fieldEnd = markStop(data);
                }
    
                status = ParseStatus.END_RECORD;
                
                return segment(data, fieldStart, fieldEnd);
            }

            /*
             * If the file didn't end with CRLF or LF
             * We will have no data left to read.
             */
            if (!data.hasRemaining()) {
                status = ParseStatus.END_DOCUMENT;
                //Include the last byte
                fieldEnd = markStop(data) + 1;

                return segment(data, fieldStart, fieldEnd);
            }
        }
    }

    private ByteBuffer segment(ByteBuffer data, int fieldStart, int fieldEnd) {
        return data.slice(fieldStart, fieldEnd - fieldStart);
    }

    /**
     * 
     * Returns a slice of the supplied buffer by
     * excluding the leading and trailing white spaces.
     * 
     * @param buff The ByteBuffer to trim.
     * 
     * @return A new ByteBuffer that is a slice of the supplied
     * ByteBuffer. The original ByteBuffer is left unaltered.
     */
    public static ByteBuffer trim(ByteBuffer buff) {
        if (buff.limit() == 0) {
            return buff;
        }

        int start = 0;
        int end = 0;
        int i;
        final int MAX_INDEX = buff.limit() - 1;

        for (i = 0; i < buff.limit(); ++i) {
            var ch = buff.get(i);

            if (ch != 32 && ch != 9) {
                break;
            }
        }

        //Clip start to max index.
        start = Math.min(i, MAX_INDEX);

        for (i = buff.limit() - 1; i >= 0; --i) {
            var ch = buff.get(i);

            if (ch != 32 && ch != 9) {
                break;
            }

            //Early breaking
            if (i < start) {
                break;
            }
        }

        end = i;

        if (end < start) {
            //This happens for a completely white space string.
            end = start - 1;
        }

        if (start == 0 && end == buff.limit() - 1) {
            //Nothing to trim
            return buff;
        } else {
            return buff.slice(start, end - start + 1);
        }
    }

    /**
     * <p>Parses the ByteBuffer into a double. Aside from digits 0-9 only 
     * a leading "-" and a decimal "." character are permitted.</p>
     * 
     * <p>Valid values: -0.001, 100, -100, -.001, -12.001</p>
     * 
     * @param buff The ByteBuffer to parse.
     * 
     * @return The parsed double value.
     */
    public static double parseDouble(ByteBuffer buff) {
        double result = 0.0;
        int decimalBase = 1;
        int base = 1;
        boolean hasDecimal = false;
     
        /*
         * Java's Double.parseDouble() trims the String.
         * Let's do the same.
         */
        buff = trim(buff);

        for (int i = buff.limit() - 1; i >= 0; --i) {
            int ch = buff.get(i);
     
            //Deal with minus sign
            if (i == 0 && ch == 45) {
                result *= -1;
     
                continue;
            }

            if (ch == 46) {
                hasDecimal = true;

                continue;
            }
     
            if (ch < 48 || ch > 57) {
                throw new NumberFormatException("Invalid input.");
            }
     
            int digit = buff.get(i) - 48;
     
            result = result + digit * base;
     
            base = base * 10;

            if (!hasDecimal) {
                decimalBase *= 10;
            }
        }
     
        if (hasDecimal) {
            return result / decimalBase;
        } else {
            return result;
        }
    }

    /**
     * <p>Parses the ByteBuffer into an integer. Aside from digits 0-9 only 
     * a leading "-" character is permitted.</p>
     * 
     * <p>Valid values: 100, -100, -0012</p>
     * 
     * @param buff The ByteBuffer to parse.
     * 
     * @return The parsed integer value.
     */
    public static int parseInt(ByteBuffer buff) {
        int result = 0;
        int base = 1;

        /*
         * Java's Integer.parseInt() trims the String.
         * Let's do the same.
         */
        buff = trim(buff);
        
        for (int i = buff.limit() - 1; i >= 0; --i) {
            int ch = buff.get(i);
     
            //Deal with minus sign
            if (i == 0 && ch == 45) {
                result *= -1;
     
                continue;
            }
     
            if (ch < 48 || ch > 57) {
                throw new NumberFormatException("Invalid input.");
            }
     
            int digit = buff.get(i) - 48;
     
            result = result + digit * base;
     
            base = base * 10;
        }
     
        return result;
    }    
}
