/*
 * This source file was generated by the Gradle 'init' task
 */
package org.mobiarch.jcsv;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.function.Consumer;

public class Parser {
    /**
     * This class represents a record (line or row) in a CSV
     * document.
     */
    public class Record {
        private int lineIndex;
        private int numFields;
        private ByteBuffer[] fields;

        /**
         * Returns the index of the line starting with 0.
         * @return The zero based line number of the record.
         */
        public int lineIndex() {
            return lineIndex;
        }

        /**
         * Returns the number of fields available in the record.
         * This will not be more than the maxFields parameter supplied
         * to Parser.parse() method.
         * @return The number of fields available in the record.
         */
        public int numFields() {
            return numFields;
        }

        private ByteBuffer[] fields() {
            return fields;
        }

        /**
         * Returns a field for the specified index.
         * 
         * @param index The index of the field.
         * @return A ByteBuffer representing the field.
         */
        public ByteBuffer field(int index) {
            if (index >= numFields) {
                throw new ArrayIndexOutOfBoundsException("Fields available: " + numFields);
            }

            return fields[index];
        }
    }

    private enum ParseStatus {
        INVALID_STATE,
        HAS_MORE_FIELDS,
        END_RECORD,
        END_DOCUMENT
    }

    ParseStatus status = ParseStatus.INVALID_STATE;

    /**
     * <p>Memory maps a UTF-8 encoded CSV file and parses it. 
     * For each record (line) the supplied
     * consumer function is called. Each record is made up
     * of zero or more comma separated fields.</p>
     * 
     * <p>No new memory is allocated or copied for the text data.
     * Each field is a slice into the data stored in the file.</p>
     * 
     * @param filePath The CSV file to parse.
     * @param maxFields Maximum number of fields that will be returned
     * to the consumer function. If you have more fields in a line then the 
     * excess ones are ignored.
     * @param f The consumer function that is called for each record (line). It
     * receoves a Record object as input.
     */
    public void parse(String filePath, int maxFields, Consumer<Record> f) throws FileNotFoundException, IOException {
        try (var file = new RandomAccessFile(filePath, "r")) {
            //Memory map the file
            var buff = file.getChannel()
                    .map(FileChannel.MapMode.READ_ONLY, 0, file.length());

            parse(buff, maxFields, f);
        } 
    }

    /**
     * <p>Parses a UTF-8 encoded ByteBuffer for comma
     * separate records. For each record (line) the supplied
     * consumer function is called. Each record is made up
     * of zero or more comma separated fields.</p>
     * 
     * <p>No new memory is allocated or copied for the text data.
     * Each field is a slice into the supplied data.</p>
     * 
     * @param data The ByteBuffer to parse.
     * @param maxFields Maximum number of fields that will be returned
     * to the consumer function. If you have more fields in a line then the 
     * excess ones are ignored.
     * @param f The consumer function that is called for each record (line). It
     * receoves a Record object as input.
     */
    public void parse(ByteBuffer data, int maxFields, Consumer<Record> f) {
        var record = new Record();
        var fields = new ByteBuffer[maxFields];

        record.fields = fields;

        status = ParseStatus.INVALID_STATE;
        int index = 0;

        while (true) {
            parseRecord(data, record);
            
            if (status == ParseStatus.END_DOCUMENT) {
                if (record.numFields() == 0) {
                    break;
                } else {
                    //This happens when a file doesn't end 
                    //properly with a CR LF or LF.
                }
            }

            record.lineIndex = index;

            f.accept(record);

            ++index;
        }
    }

    /**
     * Get the byte at current position without advancing the position.
     * 
     * @param data
     * @return
     */
    private byte peek(ByteBuffer data) {
        return data.get(data.position());
    }

    private byte pop(ByteBuffer data) {
        return data.get();
    }

    /**
     * Parses a single line at the current position.
     * 
     * @param data
     * @param record
     * @return
     */
    private void parseRecord(ByteBuffer data, Record record) {
        record.numFields = 0;
        status = ParseStatus.INVALID_STATE;

        while (true) {
            ByteBuffer field = nextField(data);

            if (field != null && record.numFields() < record.fields().length) {
                record.fields()[record.numFields()] = field;

                ++record.numFields;
            }

            if (status == ParseStatus.END_RECORD ||
                status == ParseStatus.END_DOCUMENT) {
                return;
            }
        }
    }

    private int markStop(ByteBuffer data) {
        return data.position() > 0 ? (data.position() - 1) : 0;
    }

    private ByteBuffer nextField(ByteBuffer data) {
        boolean insideDquote = false;
        boolean escapedField = false;
        int fieldStart = data.position();
        int fieldEnd = -1;//markStop(data);

        while (true) {
            if (!data.hasRemaining()) {
                status = ParseStatus.END_DOCUMENT;

                return null;
            }

            byte ch = pop(data);

            if (ch == '"') {
                if (!insideDquote) {
                    insideDquote = true;
                    escapedField = true;

                    fieldStart = data.position();
                } else {
                    if (peek(data) == '"') {
                        // Still inside dquote
                        pop(data);
                    } else {
                        // We are out of dquote
                        insideDquote = false;

                        fieldEnd = markStop(data);
                    }
                }

                continue;
            }

            if (insideDquote) {
                continue;
            }

            if (ch == ',') {
                if (!escapedField) {
                    fieldEnd = markStop(data);
                }
                
                status = ParseStatus.HAS_MORE_FIELDS;

                return segment(data, fieldStart, fieldEnd);
            }
            
            if (ch == '\r') {
                if (!escapedField) {
                    fieldEnd = markStop(data);
                }
                
                pop(data); //Read the LF \n

                status = ParseStatus.END_RECORD;
                
                return segment(data, fieldStart, fieldEnd);
            }
            
            /*
             * Non-standard end of line with just a LF \n
             */
            if (ch == '\n') {
                if (!escapedField) {
                    fieldEnd = markStop(data);
                }
    
                status = ParseStatus.END_RECORD;
                
                return segment(data, fieldStart, fieldEnd);
            }

            /*
             * If the file didn't end with CRLF or LF
             * We will have no data left to read.
             */
            if (!data.hasRemaining()) {
                status = ParseStatus.END_DOCUMENT;
                //Include the last byte
                fieldEnd = markStop(data) + 1;

                return segment(data, fieldStart, fieldEnd);
            }
        }
    }

    private ByteBuffer segment(ByteBuffer data, int fieldStart, int fieldEnd) {
        return data.slice(fieldStart, fieldEnd - fieldStart);
    }
}
